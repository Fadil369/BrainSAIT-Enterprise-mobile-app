//
// Copyright © 2023-2024 Apple Inc. All rights reserved.
//

use crate::base::base_constants::FPS_MAX_TITLE_ID_LENGTH;
use crate::base::base_constants::FPS_OFFLINE_CONTENTID_LENGTH;
use crate::base::structures::base_fps_structures::Base;
use crate::base::structures::base_server_structures::{FPSServerSPCContainer, FPSServerTLLV};
use crate::base::Utils::FPSServerUtils::{readBigEndianU32, readBigEndianU64, readBytes};
use crate::validate::{FPSStatus, Result};
use crate::{fpsLogError, returnErrorStatus};

impl Base {
    pub fn parseTagOfflineSync(tllv: &FPSServerTLLV, spcContainer: &mut FPSServerSPCContainer) -> Result<()> {
        // 4B Version
        let tllvVersion = readBigEndianU32(&tllv.value, 0)?;

        // 4B Reserved
        let reserved = readBigEndianU32(&tllv.value, 4)?;

        if tllvVersion == 1 {
            // TLLV v1 should not be used anymore, but keep support for now

            if reserved != 0 {
                fpsLogError!(FPSStatus::paramErr, "Invalid reserved field in Sync Rental TLLV");
                returnErrorStatus!(FPSStatus::paramErr);
            }

            // 4B Duration to Expiry
            spcContainer.spcData.durationToRentalExpiry = readBigEndianU32(&tllv.value, 24)?;
        } else if tllvVersion == 2 {
            /*
            SyncTLLV v2:

                Field name              Byte range  Description
                TLLV tag                0-7         An 8-byte value of 0x77966de1dc1083ad.
                Total Length            8-11        The total length of this TLLV block in bytes. The length is determined by the amount of padding at the end of the block, if any; this value must be a multiple of 16 and greater than 32.
                Value Length            12-15       The length of the content of this TLLV block in bytes.
                Version                 16-19       TLLV version. For iOS 12.3 and above the version is set to 2. (Link to structure for v1)
                Reserved                20-23       This field is reserved and it’s value should be ignored
                Server Challenge        24-31       Unique 64 bit server challenge generated by the server
                Flags                   32-39       64 bit integer. See below for flags definition
                Title ID                40-55       128 bit title ID
                Duration to Expiry      56-59       Remaining license validity time in seconds.
                Records Invalidated     60-63       Total number of invalidated records
                Invalidated Content IDs 64-X        Concatenated array of invalidated Content IDs
            */

            // 8B Server Challenge
            spcContainer.spcData.syncServerChallenge = readBigEndianU64(&tllv.value, 8)?;

            // 8B Flags
            spcContainer.spcData.syncFlags = readBigEndianU64(&tllv.value, 16)?;

            // 16B Title ID
            spcContainer.spcData.syncTitleId = readBytes(&tllv.value, 24, FPS_MAX_TITLE_ID_LENGTH)?;

            // 4B Duration to Expiry
            spcContainer.spcData.durationToRentalExpiry = readBigEndianU32(&tllv.value, 40)?;

            // 4B Records Invalidated
            spcContainer.spcData.recordsDeleted = readBigEndianU32(&tllv.value, 44)? as usize;

            if spcContainer.spcData.recordsDeleted > 250 {
                fpsLogError!(
                    FPSStatus::internalErr,
                    "parseSyncRental: abnormally large number of deleted records: {}",
                    spcContainer.spcData.recordsDeleted
                );
                returnErrorStatus!(FPSStatus::internalErr);
            } else if spcContainer.spcData.recordsDeleted > 0 {
                let recordsSizeToRead: usize = spcContainer.spcData.recordsDeleted * FPS_OFFLINE_CONTENTID_LENGTH;

                // Invalidated Content IDs (variable size)
                spcContainer.spcData.deletedContentIDs = readBytes(&tllv.value, 48, recordsSizeToRead)?;
            }
        }

        Ok(())
    }
}
